// Code generated by protoc-gen-go. DO NOT EDIT.
// source: port_msg.proto

package bess_pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PCAPPortArg struct {
	Dev                  string   `protobuf:"bytes,1,opt,name=dev,proto3" json:"dev,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PCAPPortArg) Reset()         { *m = PCAPPortArg{} }
func (m *PCAPPortArg) String() string { return proto.CompactTextString(m) }
func (*PCAPPortArg) ProtoMessage()    {}
func (*PCAPPortArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f2b1e7e1410aea8, []int{0}
}

func (m *PCAPPortArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PCAPPortArg.Unmarshal(m, b)
}
func (m *PCAPPortArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PCAPPortArg.Marshal(b, m, deterministic)
}
func (m *PCAPPortArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PCAPPortArg.Merge(m, src)
}
func (m *PCAPPortArg) XXX_Size() int {
	return xxx_messageInfo_PCAPPortArg.Size(m)
}
func (m *PCAPPortArg) XXX_DiscardUnknown() {
	xxx_messageInfo_PCAPPortArg.DiscardUnknown(m)
}

var xxx_messageInfo_PCAPPortArg proto.InternalMessageInfo

func (m *PCAPPortArg) GetDev() string {
	if m != nil {
		return m.Dev
	}
	return ""
}

type PMDPortArg struct {
	Loopback bool `protobuf:"varint,1,opt,name=loopback,proto3" json:"loopback,omitempty"`
	// Types that are valid to be assigned to Port:
	//	*PMDPortArg_PortId
	//	*PMDPortArg_Pci
	//	*PMDPortArg_Vdev
	Port isPMDPortArg_Port `protobuf_oneof:"port"`
	// See http://dpdk.org/doc/dts/test_plans/dual_vlan_test_plan.html
	VlanOffloadRxStrip   bool     `protobuf:"varint,5,opt,name=vlan_offload_rx_strip,json=vlanOffloadRxStrip,proto3" json:"vlan_offload_rx_strip,omitempty"`
	VlanOffloadRxFilter  bool     `protobuf:"varint,6,opt,name=vlan_offload_rx_filter,json=vlanOffloadRxFilter,proto3" json:"vlan_offload_rx_filter,omitempty"`
	VlanOffloadRxQinq    bool     `protobuf:"varint,7,opt,name=vlan_offload_rx_qinq,json=vlanOffloadRxQinq,proto3" json:"vlan_offload_rx_qinq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PMDPortArg) Reset()         { *m = PMDPortArg{} }
func (m *PMDPortArg) String() string { return proto.CompactTextString(m) }
func (*PMDPortArg) ProtoMessage()    {}
func (*PMDPortArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f2b1e7e1410aea8, []int{1}
}

func (m *PMDPortArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PMDPortArg.Unmarshal(m, b)
}
func (m *PMDPortArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PMDPortArg.Marshal(b, m, deterministic)
}
func (m *PMDPortArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PMDPortArg.Merge(m, src)
}
func (m *PMDPortArg) XXX_Size() int {
	return xxx_messageInfo_PMDPortArg.Size(m)
}
func (m *PMDPortArg) XXX_DiscardUnknown() {
	xxx_messageInfo_PMDPortArg.DiscardUnknown(m)
}

var xxx_messageInfo_PMDPortArg proto.InternalMessageInfo

func (m *PMDPortArg) GetLoopback() bool {
	if m != nil {
		return m.Loopback
	}
	return false
}

type isPMDPortArg_Port interface {
	isPMDPortArg_Port()
}

type PMDPortArg_PortId struct {
	PortId uint64 `protobuf:"varint,2,opt,name=port_id,json=portId,proto3,oneof"`
}

type PMDPortArg_Pci struct {
	Pci string `protobuf:"bytes,3,opt,name=pci,proto3,oneof"`
}

type PMDPortArg_Vdev struct {
	Vdev string `protobuf:"bytes,4,opt,name=vdev,proto3,oneof"`
}

func (*PMDPortArg_PortId) isPMDPortArg_Port() {}

func (*PMDPortArg_Pci) isPMDPortArg_Port() {}

func (*PMDPortArg_Vdev) isPMDPortArg_Port() {}

func (m *PMDPortArg) GetPort() isPMDPortArg_Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *PMDPortArg) GetPortId() uint64 {
	if x, ok := m.GetPort().(*PMDPortArg_PortId); ok {
		return x.PortId
	}
	return 0
}

func (m *PMDPortArg) GetPci() string {
	if x, ok := m.GetPort().(*PMDPortArg_Pci); ok {
		return x.Pci
	}
	return ""
}

func (m *PMDPortArg) GetVdev() string {
	if x, ok := m.GetPort().(*PMDPortArg_Vdev); ok {
		return x.Vdev
	}
	return ""
}

func (m *PMDPortArg) GetVlanOffloadRxStrip() bool {
	if m != nil {
		return m.VlanOffloadRxStrip
	}
	return false
}

func (m *PMDPortArg) GetVlanOffloadRxFilter() bool {
	if m != nil {
		return m.VlanOffloadRxFilter
	}
	return false
}

func (m *PMDPortArg) GetVlanOffloadRxQinq() bool {
	if m != nil {
		return m.VlanOffloadRxQinq
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PMDPortArg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PMDPortArg_PortId)(nil),
		(*PMDPortArg_Pci)(nil),
		(*PMDPortArg_Vdev)(nil),
	}
}

type UnixSocketPortArg struct {
	/// Set the first character to "@" in place of \0 for abstract path
	/// See manpage for unix(7).
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	/// Minimum RX polling interval for system calls, when *idle*.
	/// Use a negative number for unthrottled polling. If unspecified or 0,
	/// it is set to 50,000 (50 microseconds, or 20k polls per second)
	MinRxIntervalNs int64 `protobuf:"varint,2,opt,name=min_rx_interval_ns,json=minRxIntervalNs,proto3" json:"min_rx_interval_ns,omitempty"`
	/// If set, the port driver will send a confirmation once
	/// the port is connected.  This lets pybess avoid a race during
	/// testing.  See bessctl/test_utils.py for details.
	ConfirmConnect       bool     `protobuf:"varint,3,opt,name=confirm_connect,json=confirmConnect,proto3" json:"confirm_connect,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnixSocketPortArg) Reset()         { *m = UnixSocketPortArg{} }
func (m *UnixSocketPortArg) String() string { return proto.CompactTextString(m) }
func (*UnixSocketPortArg) ProtoMessage()    {}
func (*UnixSocketPortArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f2b1e7e1410aea8, []int{2}
}

func (m *UnixSocketPortArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnixSocketPortArg.Unmarshal(m, b)
}
func (m *UnixSocketPortArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnixSocketPortArg.Marshal(b, m, deterministic)
}
func (m *UnixSocketPortArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnixSocketPortArg.Merge(m, src)
}
func (m *UnixSocketPortArg) XXX_Size() int {
	return xxx_messageInfo_UnixSocketPortArg.Size(m)
}
func (m *UnixSocketPortArg) XXX_DiscardUnknown() {
	xxx_messageInfo_UnixSocketPortArg.DiscardUnknown(m)
}

var xxx_messageInfo_UnixSocketPortArg proto.InternalMessageInfo

func (m *UnixSocketPortArg) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *UnixSocketPortArg) GetMinRxIntervalNs() int64 {
	if m != nil {
		return m.MinRxIntervalNs
	}
	return 0
}

func (m *UnixSocketPortArg) GetConfirmConnect() bool {
	if m != nil {
		return m.ConfirmConnect
	}
	return false
}

type VPortArg struct {
	Ifname string `protobuf:"bytes,1,opt,name=ifname,proto3" json:"ifname,omitempty"`
	// Types that are valid to be assigned to Cpid:
	//	*VPortArg_Docker
	//	*VPortArg_ContainerPid
	//	*VPortArg_Netns
	Cpid                 isVPortArg_Cpid `protobuf_oneof:"cpid"`
	RxqCpus              []int64         `protobuf:"varint,5,rep,packed,name=rxq_cpus,json=rxqCpus,proto3" json:"rxq_cpus,omitempty"`
	TxTci                uint64          `protobuf:"varint,6,opt,name=tx_tci,json=txTci,proto3" json:"tx_tci,omitempty"`
	TxOuterTci           uint64          `protobuf:"varint,7,opt,name=tx_outer_tci,json=txOuterTci,proto3" json:"tx_outer_tci,omitempty"`
	Loopback             bool            `protobuf:"varint,8,opt,name=loopback,proto3" json:"loopback,omitempty"`
	IpAddrs              []string        `protobuf:"bytes,9,rep,name=ip_addrs,json=ipAddrs,proto3" json:"ip_addrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *VPortArg) Reset()         { *m = VPortArg{} }
func (m *VPortArg) String() string { return proto.CompactTextString(m) }
func (*VPortArg) ProtoMessage()    {}
func (*VPortArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f2b1e7e1410aea8, []int{3}
}

func (m *VPortArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VPortArg.Unmarshal(m, b)
}
func (m *VPortArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VPortArg.Marshal(b, m, deterministic)
}
func (m *VPortArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPortArg.Merge(m, src)
}
func (m *VPortArg) XXX_Size() int {
	return xxx_messageInfo_VPortArg.Size(m)
}
func (m *VPortArg) XXX_DiscardUnknown() {
	xxx_messageInfo_VPortArg.DiscardUnknown(m)
}

var xxx_messageInfo_VPortArg proto.InternalMessageInfo

func (m *VPortArg) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

type isVPortArg_Cpid interface {
	isVPortArg_Cpid()
}

type VPortArg_Docker struct {
	Docker string `protobuf:"bytes,2,opt,name=docker,proto3,oneof"`
}

type VPortArg_ContainerPid struct {
	ContainerPid int64 `protobuf:"varint,3,opt,name=container_pid,json=containerPid,proto3,oneof"`
}

type VPortArg_Netns struct {
	Netns string `protobuf:"bytes,4,opt,name=netns,proto3,oneof"`
}

func (*VPortArg_Docker) isVPortArg_Cpid() {}

func (*VPortArg_ContainerPid) isVPortArg_Cpid() {}

func (*VPortArg_Netns) isVPortArg_Cpid() {}

func (m *VPortArg) GetCpid() isVPortArg_Cpid {
	if m != nil {
		return m.Cpid
	}
	return nil
}

func (m *VPortArg) GetDocker() string {
	if x, ok := m.GetCpid().(*VPortArg_Docker); ok {
		return x.Docker
	}
	return ""
}

func (m *VPortArg) GetContainerPid() int64 {
	if x, ok := m.GetCpid().(*VPortArg_ContainerPid); ok {
		return x.ContainerPid
	}
	return 0
}

func (m *VPortArg) GetNetns() string {
	if x, ok := m.GetCpid().(*VPortArg_Netns); ok {
		return x.Netns
	}
	return ""
}

func (m *VPortArg) GetRxqCpus() []int64 {
	if m != nil {
		return m.RxqCpus
	}
	return nil
}

func (m *VPortArg) GetTxTci() uint64 {
	if m != nil {
		return m.TxTci
	}
	return 0
}

func (m *VPortArg) GetTxOuterTci() uint64 {
	if m != nil {
		return m.TxOuterTci
	}
	return 0
}

func (m *VPortArg) GetLoopback() bool {
	if m != nil {
		return m.Loopback
	}
	return false
}

func (m *VPortArg) GetIpAddrs() []string {
	if m != nil {
		return m.IpAddrs
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VPortArg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VPortArg_Docker)(nil),
		(*VPortArg_ContainerPid)(nil),
		(*VPortArg_Netns)(nil),
	}
}

func init() {
	proto.RegisterType((*PCAPPortArg)(nil), "bess.pb.PCAPPortArg")
	proto.RegisterType((*PMDPortArg)(nil), "bess.pb.PMDPortArg")
	proto.RegisterType((*UnixSocketPortArg)(nil), "bess.pb.UnixSocketPortArg")
	proto.RegisterType((*VPortArg)(nil), "bess.pb.VPortArg")
}

func init() { proto.RegisterFile("port_msg.proto", fileDescriptor_8f2b1e7e1410aea8) }

var fileDescriptor_8f2b1e7e1410aea8 = []byte{
	// 465 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x52, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x6d, 0x97, 0x34, 0x49, 0x2f, 0x63, 0x63, 0x97, 0xad, 0xca, 0x78, 0xa1, 0xaa, 0x84, 0xa8,
	0x84, 0x34, 0x84, 0xf6, 0x05, 0xa5, 0x08, 0x75, 0x0f, 0xb0, 0xe2, 0x01, 0xaf, 0x56, 0xea, 0xa4,
	0xe3, 0x6a, 0xad, 0xed, 0x38, 0x6e, 0xe5, 0x17, 0x7e, 0x81, 0x6f, 0x46, 0x76, 0xd3, 0x8a, 0x8d,
	0x37, 0x9f, 0x73, 0x7c, 0x7c, 0x92, 0x73, 0x2f, 0x9c, 0x68, 0x65, 0x2c, 0x5f, 0x37, 0xf7, 0x57,
	0xda, 0x28, 0xab, 0x30, 0x5d, 0x54, 0x4d, 0x73, 0xa5, 0x17, 0xa3, 0xd7, 0xf0, 0x6c, 0x3e, 0x9d,
	0xcc, 0xe7, 0xca, 0xd8, 0x89, 0xb9, 0xc7, 0x17, 0x10, 0x95, 0xd5, 0x36, 0xef, 0x0e, 0xbb, 0xe3,
	0x3e, 0xf3, 0xc7, 0xd1, 0x9f, 0x23, 0x80, 0xf9, 0x97, 0x4f, 0xfb, 0x0b, 0xaf, 0x20, 0x5b, 0x29,
	0xa5, 0x17, 0x85, 0x78, 0x08, 0xb7, 0x32, 0x76, 0xc0, 0x78, 0x09, 0x69, 0x88, 0xa1, 0x32, 0x3f,
	0x1a, 0x76, 0xc7, 0xf1, 0xac, 0xc3, 0x12, 0x4f, 0xdc, 0x94, 0x88, 0x10, 0x69, 0x41, 0x79, 0xe4,
	0xdf, 0x9d, 0x75, 0x98, 0x07, 0x78, 0x0e, 0xf1, 0xd6, 0x87, 0xc5, 0x2d, 0x19, 0x10, 0x7e, 0x80,
	0x8b, 0xed, 0xaa, 0x90, 0x5c, 0x2d, 0x97, 0x2b, 0x55, 0x94, 0xdc, 0x38, 0xde, 0x58, 0x43, 0x3a,
	0xef, 0x85, 0x34, 0xf4, 0xe2, 0xed, 0x4e, 0x63, 0xee, 0xce, 0x2b, 0x78, 0x0d, 0x83, 0xa7, 0x96,
	0x25, 0xad, 0x6c, 0x65, 0xf2, 0x24, 0x78, 0x5e, 0x3e, 0xf2, 0x7c, 0x0e, 0x12, 0xbe, 0x87, 0xf3,
	0xa7, 0xa6, 0x9a, 0x64, 0x9d, 0xa7, 0xc1, 0x72, 0xf6, 0xc8, 0xf2, 0x8d, 0x64, 0xfd, 0x31, 0x81,
	0xd8, 0xff, 0xcc, 0xe8, 0x37, 0x9c, 0xfd, 0x90, 0xe4, 0xee, 0x94, 0x78, 0xa8, 0xec, 0xbe, 0x16,
	0x84, 0x58, 0x17, 0xf6, 0x57, 0x5b, 0x5c, 0x38, 0xe3, 0x3b, 0xc0, 0x35, 0x49, 0xff, 0x30, 0x49,
	0x5b, 0x99, 0x6d, 0xb1, 0xe2, 0xb2, 0x09, 0xcd, 0x44, 0xec, 0x74, 0x4d, 0x92, 0xb9, 0x9b, 0x96,
	0xff, 0xda, 0xe0, 0x5b, 0x38, 0x15, 0x4a, 0x2e, 0xc9, 0xac, 0xb9, 0x50, 0x52, 0x56, 0xc2, 0x86,
	0xb2, 0x32, 0x76, 0xd2, 0xd2, 0xd3, 0x1d, 0xeb, 0xe7, 0x91, 0xfd, 0xdc, 0xc7, 0x0e, 0x20, 0xa1,
	0xa5, 0x2c, 0xd6, 0x55, 0x1b, 0xdc, 0x22, 0xcc, 0x21, 0x29, 0xfd, 0xf7, 0x99, 0x10, 0xe7, 0xcb,
	0x6d, 0x31, 0xbe, 0x81, 0xe7, 0x42, 0x49, 0x5b, 0x90, 0xac, 0x0c, 0xd7, 0x54, 0x86, 0x94, 0x68,
	0xd6, 0x61, 0xc7, 0x07, 0x7a, 0x4e, 0x25, 0x0e, 0xa0, 0x27, 0x2b, 0x2b, 0x9b, 0xc3, 0x70, 0x76,
	0x10, 0x2f, 0x21, 0x33, 0xae, 0xe6, 0x42, 0x6f, 0x9a, 0xbc, 0x37, 0x8c, 0xc6, 0x11, 0x4b, 0x8d,
	0xab, 0xa7, 0x7a, 0xd3, 0xe0, 0x05, 0x24, 0xd6, 0x71, 0x2b, 0x28, 0xb4, 0x1e, 0xb3, 0x9e, 0x75,
	0xdf, 0x05, 0xe1, 0x10, 0x8e, 0xad, 0xe3, 0x6a, 0x63, 0x2b, 0x13, 0xc4, 0x34, 0x88, 0x60, 0xdd,
	0xad, 0xa7, 0xfc, 0x8d, 0x7f, 0x57, 0x2a, 0xfb, 0x6f, 0xa5, 0x32, 0xd2, 0xbc, 0x28, 0x4b, 0xd3,
	0xe4, 0xfd, 0x61, 0x34, 0xee, 0xb3, 0x94, 0xf4, 0xc4, 0x43, 0x3f, 0x0f, 0xa1, 0xa9, 0x5c, 0x24,
	0x61, 0xa3, 0xaf, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x23, 0xd9, 0xa1, 0xe3, 0x02, 0x00,
	0x00,
}
